# midisynth-rs
[![Rust](https://img.shields.io/badge/Rust-%23000000.svg?e&logo=rust&logoColor=white)](#)

A quick-and-dirty tool to synthesize MIDI files generated by
[LilyPond](https://lilypond.org/) using soundfonts.

The hard work is performed by the following 3rd-party crates:
- [Midly](https://crates.io/crates/midly) is used to read and parse MIDI files.
- [RustySynth](https://crates.io/crates/rustysynth) is used to synthesize the
  music using the chosen soundfonts.
- [WaveRS](https://crates.io/crates/wavers) is used to write the resulting
  audio WAV files.

## Background

When generating MIDI output, Lilypond will place the music from each staff (or
even voice, depending on the [`Score.midiChannelMapping`
setting](https://lilypond.org/doc/Documentation/notation/midi-channel-mapping))
on a separate track. This is very convenient, especially when working with
large scores. The number of tracks in a MIDI file is practically[^tracklimit]
unlimited, whereas the total number of channels cannot exceed 16.

`midisynth-rs` will ignore channels and their associated instrument ("program")
settings, and instead render each track found in the MIDI file separately
according to a user-defined mapping. Finally, it mixes the generated tracks
together to produce the final audio file.

## Rendering Process

This section is meant to describe (roughly) the inner workings of this tool.

### Step 1: Sequencing

In this step, the MIDI file is "sequenced", i.e. all (relevant) MIDI events are
processed and translated into real-time. In other words, this converts the
relative MIDI ticks into absolute microsecond timestamps based on the tempo and
timing settings in the file. In this step, the music events are also separated
by tracks.

The result is a `Vec<PlayerTrack>`, where each `PlayerTrack` corresponds to a
track. Each contains the relevant events, namely the notes to be played and an
absolute timestamp.

### Step 2: Rendering

During this step, each track is separately rendered using RustySynth, based on
the mapping found in the configuration TOML file.

Since each track can be rendered independently, a new thread is spawned for
each to enable parallel processing.

For each track, the output is a `(Vec<f32>, Vec<f32>)` that contains the stereo
samples generated for the left and right track respectively.


### Step 3: Mixing

Finally, all tracks are mixed together into a single audio file. Again, the mix
is created based on settings from the configuration TOML file. For each track,
a gain (in dB) and a pan setting (in the range from -1 to 1) can be specified.

The output of this step is a `Vec<f32>` which contains the mixed stereo track
with interleaved left/right samples.


---

[^tracklimit]: The actual limit is technically 65,535.
